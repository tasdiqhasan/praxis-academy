/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package testing;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.concurrent.*;
import java.util.*;

public class BlockingTest {
    
    @Test
    public void testPutOnEmptyQueueBlocks() throws InterruptedException {
        final SimpleBlockingQueue queue = new SimpleBlockingQueue();
        BlockingThread blockingThread = new BlockingThread(queue);
        blockingThread.start();
        Thread.sleep(5000);
        assertFalse(blockingThread.isReachedAfterGet());
        assertFalse(blockingThread.isWasInterrupted());
        assertFalse(blockingThread.isThrowableThrown());
        queue.put(new Object());
        Thread.sleep(1000);
        assertTrue(blockingThread.isReachedAfterGet());
        assertFalse(blockingThread.isWasInterrupted());
        assertFalse(blockingThread.isThrowableThrown());
        blockingThread.join();
    }

    @Test
    public void testParallelInsertionAndConsumption() throws InterruptedException, ExecutionException {
        final SimpleBlockingQueue<Integer> queue = new SimpleBlockingQueue<Integer>();
        ExecutorService threadPool = Executors.newFixedThreadPool(2);
        final CountDownLatch latch = new CountDownLatch(2);
        List<Future<Integer>> futuresPut = new ArrayList<Future<Integer>>();
        for (int i = 0; i < 3; i++) {
            Future<Integer> submit = threadPool.submit(new Callable<Integer>() {
                public Integer call() {
                    int sum = 0;
                    for (int i = 0; i < 1000; i++) {
                        int nextInt = ThreadLocalRandom.current().nextInt(100);
                        queue.put(nextInt);
                        sum += nextInt;
                    }
                    latch.countDown();
                    return sum;
                }
            });
            futuresPut.add(submit);
        }
        List<Future<Integer>> futuresGet = new ArrayList<Future<Integer>>();
        for (int i = 0; i < 3; i++) {
            Future<Integer> submit = threadPool.submit(new Callable<Integer>() {
                public Integer call() {
                    int count = 0;
                    try {
                        for (int i = 0; i < 1000; i++) {
                            Integer got = queue.get();
                            count += got;
                        }
                    } catch (InterruptedException e) {
     
                    }
                    latch.countDown();
                    return count;
                }
            });
            futuresGet.add(submit);
        }
        latch.await();
        int sumPut = 0;
        for (Future<Integer> future : futuresPut) {
            sumPut += future.get();
        }
        int sumGet = 0;
        for (Future<Integer> future : futuresGet) {
            sumGet += future.get();
        }
        assertEquals(sumPut, sumGet);
    }

    @Test
    public void testPerformance() throws InterruptedException {
        for (int numThreads = 1; numThreads < 2; numThreads++) {
            long startMillis = System.currentTimeMillis();
            final SimpleBlockingQueue<Integer> queue = new SimpleBlockingQueue<Integer>();
            ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);
            for (int i = 0; i < numThreads; i++) {
                threadPool.submit(new Runnable() {
                    public void run() {
                        for (long i = 0; i < 2; i++) {
                            int nextInt = ThreadLocalRandom.current().nextInt(100);
                            try {
                                queue.put(nextInt);
                                nextInt = queue.get();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                });
            }
            threadPool.shutdown();
            threadPool.awaitTermination(5, TimeUnit.MINUTES);
            long totalMillis = System.currentTimeMillis() - startMillis;
            double throughput = (double)(numThreads * 2 * 2) / (double) totalMillis;
            System.out.println(String.format("%s with %d threads: %dms (throughput: %.1f ops/s)", LinkedBlockingQueue.class.getSimpleName(), numThreads, totalMillis, throughput));
        }
    }
}
